ChannelHandler 他的实现负责接收并相应事件通知，可以是使用ChannelInboundHandlerAdapter类，提供了默认的
ChannelInboundHandler的实现
channelRead 对每个传入的消息都要调用
channelReadComplete 通知ChannelInboundHandler最后一个对channelRead()的调用时当前批量读取的最后一条消息。
exceptionCaught 在读取期间，有一场抛出时会调用

ChannelInitializer 一个CHannleHandler的实例，
当一个新的连接被接受时，会产生一个新的Channel将会被创建，而CHannelInitializr将会把一个你的
自定义个CHannelHandler添加到这个Channel的CHannelPipeline中，这个CHannelHandler会受到有关入栈消息的通知。
channel	NIOServerSocketChannel NioSocketChannel 
ChannelFuture 异步的future

EventLoop EventLoopGroup 使用EventLoop处理IO时间
一个EventLoop在生命周期内之和一个Thread绑定
Chaneel 所有属于通过一个Channel的操作都被保证其将以调用的顺序执行
ChannelPipeline 提供CHannelHandler链的容器。Channel创建时会被自动的分配专属的ChannelPipeline，
	1，ChannelInitializer 的实现被注册到了BootStrap中
	2，ChannelInitializer.initChannel 方法被调用，把ChannelHandler添加到ChannelPipeline链中
	3，ChannelInitializer将他自己从ChannelPipeline中移除,因为ChannelInitialixer也是一个CHannelHandler，需要移除。
channelHandler 处理逻辑，CHannelHandler接收事件，执行他们所实现的处理逻辑，并将数据传给下一个CHannelHandler，
	执行顺序是由他们被添加的顺序所决定，
	ChannelInoundHandler 接收入站事件和数据，这些数据随后将会被你的应用程序的业务逻辑所处理。
		SimpleChannelInboundHandlerAdapter
	ChannelOutboundHandler	出站事件和数据，数据的出站运动（即正在被写的数据），数据将从ChannelOutboundHandler
	链的尾端开始流动，知道它到达链的头部为止，在这之后，数据将会到达网络传输层，通常情况下会触发一个写操作。
	ChannelHandlerAdapter
	ChannelDuplexHandler
	ChannelHandler用途，1将数据从一种格式转为另外一种格式
		2，提供异常的通知，
		3，提供CHannel变为活动的或者非活动的通知，
		4，提供当Channel注册到EventLoop或从EventLoop中注销的通知
		5，提供有关用户自定义事件的通知
CHannelHandlerContext 代表CHannelHandler和ChannelPipeline之间的绑定。虽然可以获取Channel
	但主要功能还是用来写出站数据
Netty有两种消息发送机制，
	1，直接写入CHannel中，导致消息从ChannelPipeline尾端开始流动
	2，写入ChannelHandlerContext ctx中，导致消息从ChannelPipeline中的下一个CHannelHandler开始流动，ctx.fiteChannelRead
网络数据总是一系列的字节
ByteToMessageDecoder MessageToByteEncoder
BootStrap，客户端连接到远程服务器，使用一个EventLoopGroup
ServerBootStrap	，服务端，绑定本地连接，使用2个EventLoopGroup，可以使同一个实例，
	parentGroup只包含ServerChannel，代表服务器自身的已经绑定到某个本地端口的正在监听的套接字，
	parentGroup中的EventLoop负责为传入的连接请求创建Channel，EventLoopGroup负责分配这个EventLoop
	childGroup包含所有已创建的用来处理传入客户端连接的Channel

Netty的Channel是线程安全的。消息会被保证按顺序发送
零拷贝 是一种快速搞笑的将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间
Epoll linux的本地非阻塞传输
Netty 使用Epoll，linux环境，高负载情况下，可能由于JDK NIO
	只需将NioEventLoopGroup替换为EpollEventLoopGroup，NIOServerSocketChannel替换为
	EpollServerSocketChannel即可。
非阻塞代码库或一个常规的起点	NIO 或在Linux上的epoll
阻塞代码库			OIO
在同一个JVM内部的通信		Local，Default
测试ChannelHandler的实现	Embedded

ByteBuf readIndex,writeIndex,capacity, get,set方法不会触发readIndex，writeIndex的改变。	
	read,write方法改变readIndex，writeIndex，也可以手动调用readIndex(),writeIndex()方法修改这两个值。
directByteBuf，JVM堆外内存，主要是为了避免在每次调用本地I/O 操作之前（或者之后）将缓冲区的内容复
制到一个中间缓冲区（或者从中间缓冲区把内容复制到缓冲区）。不回收垃圾回收影响，当然分配和回收较为昂贵。
	回收需要full GC来回收。。。
支撑ByteBuffy  有byte[]支撑，JVM堆空间中
复合缓冲区 CompositByteBuf
	
0 >>> readIndex 可丢弃字节,调用discardReadBytes()方法，可以丢弃
他们并回收空间，只是移动可以读取的字节，writeIndex，对于可写字段的内容并没有任何保证，并不会对可写入字节区域
的数据进行擦除。discardReadBytes方法可能会导致内存复制，因为可读字节必须
被移动到缓冲区开始的位置，只有在真正需要的时候采取调用这个方法。
调用clear() 只是把readIndex,writeIndex置为0，所以相对于discardReadBytes方法轻量得多。

派生缓冲区：
	duplicate()	
	slice()	
	Unpooled.unmodifiableBuffer()
	order(ByteOrder)
	readSlice(int)
	返回新的ByteBuf，具有自己的读写索引和标记索引，内部存储是共享的，使得
	派生索引创建低廉，但是修改了内容的话，同样也会修改其对应的源实例，
复制，如果要用一个缓冲区的真实副本，使用copy方法，返回拥有独立数据的

Channel生命周期：
 	ChannelUnregistered：Channel已经被创建，但还未注册到EventLoop
	ChannelRegistered：Channel已经被注册到了EventLoop
	ChannelActive:Channel处于活动状态(已经连接到其他的远程节点)	,可以发送接收数据了
	ChannelInactive:Channel没有连接到远程节点。
	
	ChannelRegister -> ChannelActive -> ChannelInActive-> CHannelUnregistered
	
ChannelHandler的生命周期，在CHannelHandler被
	添加到ChannelPipeline或者从ChannelPipeline中移除会调用该
	这些操作，接收一个ChannelHandlerContext参数
	HandlerAdded 当把CHannelHandler添加到ChannelPipeline中
	HandlerRemove 当从ChannelPileline中移除CHannelHandler时
	exceptionCaught 当处理过程中在ChannelPipeline中有错误时被调用。

ChannelInboundHandler	
	ChannelRegistered 当Channel已经注册到他的EventLoop，并能够处理IO是被调用
	ChannelUnregistered 当Channel从他的EventLoop注销并无法处理任何IO是被调用
	ChannelActive 当Channel处于活动状态时被调用，Channel已经连接/绑定并且已经就绪
	ChannelInActive 当Channel离开活动状态并且不在连接他的远程节点是被调用
	ChannelRead 当从Channel中读取数据是被调用
	ChannelReadComplete 当Channel上的一个读操作完成时被调用
	ChannelWritabilityChanged 当Channel的可写状态发生改变时被调用，用户可以确保写操作不会完成的太快，
	（用于避免OutofMemoryError）或者可以再Channel变为再次可写时恢复写入，可以通过Channel.isWritable方法
	来检测Channel的可写性，
	userEventTriggered 当ChannelInboundHandler.fireUserEventTriggered()方法
	被调用时调用，因为一个POJO被传经了CHannelPipeline
	
	当某个ChannelInboundHandler的实现重写ChannelRead()方法时，他将负责
	现实的释放与池化的ByteBuf实例相关的内存，使用ReferenceCountUtil.release();
	使用SimpleChannelInboundHandler无需手动释放。

	ChannelOutboundHandler 出站操作和数据将由ChannelOutboundHandler处理，其中一个强大的功能
	是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求，例如，如果到远程节点的写入被暂停了，
	那么你可以推迟冲刷操作并在稍后继续。
	bind(channelHandlerContext,SocketAddress,ChannelPromise) 当请求将Channel绑定到本地地址是调用
	connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise) 当请求将Channel连接到远程节点时调用，
	disconnect(CHannelHandlerContext,ChannelPromise) 当请求将Channel从远程节点断开时被调用
	close()请求关闭时调用
	deregister() 当请求将CHannel从他的EventLoop注销时被调用，
	read() 当请求从Channel读取更多的数据时被调用。
	flush() 当请求通过CHannel将入队数据冲刷到远程节点时被调用
	write() 当请求通过CHannel将数据写入到远程节点时被调用,通过ChannelContextHandler写入不会调用。。。

池化资源回收：如果一个消息被消费或者丢弃了，并且没有传递给ChannelPipeline中的下一个ChannelHandler，那么用户就有
责任调用ReferenceCountUtil.release()。如果消息到达了实际的传输层，那么他被写入是或者Channel关闭时，都将被自动释放。
对于写的数据，每次写完之后都会release释放资源。调用write会释放资源，Channel关闭时也会再次释放资源，关闭Channel时关闭的却是DirectBuf，并不是我们申请的那一个。
对于读到的ByteBuf数据，要在最后的ChannelInboundHandler中调用ReferenceCountHandler.release方法，确定释放了资源。
	
ChannelOutboundHandler的write方法,如果消息被消费或者丢弃了,而且并没有传递给ChannelPipeline中下一个ChannelOutboundHandler那么就需要调用ReferenceCountUtil
和ChannelPromise的setSuccess之类的方法处理。

ChannelPipeline：每一个新建的ChannelPipeline都会被
	分配一个新的ChannelPipeline，Channel的生命周期内既不能附加另外一个ChannelPipeline，也不能分离器当前的
	
ChannelHandlerContext使得ChannelHandler能够和他的ChannelPipeline以及其他的CHannelHandler交互，
ChannelHandler可以通知其所属的ChannelPipeline中的下一个CHannelHandler。甚至可以动态地修改他所属的ChannelPipeline，	
	
add 添加CHannelHandler
remove	移除ChannelHandler
replace	替换
		
CHannelHandler的执行和阻塞
	通常ChannelPipeline中的每个ChannelHand而都是通过他的EventLoop来处理传递给他的事件的，所以不要阻塞这个线程，
	不要阻塞这个线程!不要阻塞这个线程！但是有时会有可能与阻塞API交互，ChannelPipeline有接收一个EventExecutorGroup的add的方法，
	如果一个事件被传递给一个自定义的EventExecutorGroup，他将被包含在这个EventExecutorGroup中的某个EventExecutor处理，从而
	被Channel本身的EventLoop中移除，对于这种用例，Netty提供了一个叫DefaultEventExecutorGroup的默认实现，
	
	ChannelPipeline用于访问ChannelHanlder的操作
	get 通过类型或者名称返回CHannelHandler
	context 返回和CHannelHandler绑定的ChannelHandlerContext
	names 返回ChannelPipeline中所有ChannelHandler的名称

ChannelPipeline的入站操作	
	FireChannelXX 调用ChannelPipeline中的下一个ChannelInboundHandler的ChannelXX方法

ChannelPipeline的出站操作
	bind -> 将Channel绑定到下一个本地地址，将调用ChannelPipeline中的下一个ChannelOutboundHandler的bind方法。
	connect	->	将Channel连接到一个远程地址，将调用ChannelPipeline中下一个ChannelOutboundHandlerHandler的connect方法
	disconnect ->	将Channel断开连接
	close -> 将Channel关闭
	deregister -> 将Channel从它先前分配的EventExecutor(EventLoop)中注销
	flush 冲刷Channel所有挂起的写入
	write -> 将消息写入Channel，这并不会将消息写入底层的Socket，而只是会把数据放入队列中，
		需要调用flush 或者 writeAndFlush方法。
	writeAndFlush 先write然后flush
	read -> 请求从Channel中读取更多的数据。	
	
	ChannelPipeline保存了与Channel相关联的CHannelHandler
	ChannelPipeline可以根据需要，通过添加或者删除Channelhandler来动态修改
	ChannelPipeline有着丰富的API，以响应入站和出站事件

ChannelHandlerContext 
	alloc 返回和实例相关联的Channel所配置ByteBufferAllocator
	bind 绑定到给定的SocketAddress,并返回ChannelFuture
	close 关闭Channel,并返回ChannelFuture
	connect 连接给定的SocketAddress，并返回ChannelFuture
	disConnect 从远程节点断开，并返回ChannelFuture。
	executor 返回调度事件的EventExecutor
	name 返回这个实例的唯一名称
	pipeline 返回这个实例所关联的ChannelPipeline
	Read
	Handler 返回绑定到这个实例的ChannelHandler
	
	ChannelHandlerContext和ChannelHandler之间的关联（绑定）是永远
	不会改变的，所以缓存对他的引用时安全的，每一个ChannelHandler都有自己的ChannelHandlerContext。
	
	ChannelHandlerContext的方法将会产生更短的事件流，应该尽可能的利用这个
	特性获得最大的性能，
	
	使用Channel的write方法会导致时间从尾端到头部流经ChannelPipeline

入站异常
如果发生异常，而且没有CHannelHandler处理那么就会抛出以下警告
2017-12-12 12:34:52 [nioEventLoopGroup-3-1] 
[i.n.channel.DefaultChannelPipeline.warn:151] WARN  - 
An exceptionCaught() event was fired, and it reached at the tail of the pipeline. 
It usually means the last handler in the pipeline did not handle the exception.

出站异常
每个出站操作都返回一个ChannelFuture，祖册到CHannelFuture的ChannleFutureListener将在完成时被通知高操作是成功
还是出错。
几乎所有的CHannelOutboundHandler的方法都会传入一个CHannelPromise的实力，作为ChannelFuture的子类，ChannelPromise
可以被分配用于异步通知的监听器，但是ChannelPromise还提供了立即通知的可写方法

setSuccess setFailure

永远不要将一个长时间运行的任务放入到执行队列中，因为它将阻塞需要在同一线程上执行的任何其他任务。
EventLoopGroup 负责为每个新创建的Channel分配一个EventLoop，一旦一个Channel被分配给了一个EventLoop，他将在他的整个生命周期
都是用这个EventLoop(以及相关联的Thread)

bootstrap 实现cloneable，但是他的拷贝是一个浅拷贝，所有的克隆的Bootstrap都会使用同一个EventLoopGroup，
这在一些情况下是可用的

EmbeddedChannel
	writeInbound() 将入栈消息写到EmbeddedChannel中，如果可以通过readInbound()方法从EmbeddedChannel中读取数据，返回true
	readInbound()	从EmbeddedChannel中读取一个入站消息，任何返回的数据都穿越了整个ChannelPipeline，如果没有任何可供读取的数据，则返回null
	writeOutbound 	将出站消息写到EmbeddedChannel中。
	readOutbound
	finish 将EmbeddedCHannel标记为完成，并且如果有可被读取得入站数据或者出站数据，则返回true，这个方法还会调用EmbeddedCHannel上的close方法
	
FixedLengthFrameDecoder
	
ByteToMessageDecoder
	decode 必须实现的唯一抽象方法。传入包含数据的bytebuf，对这个方法的调用会重复进行，以确保没有新的元素被添加到List，如果List不为空，那么他的内容会被传递给ChannelPipeline中的下一个CHannelInboundHandler
	
	decodeLast 默认实现只是简单调用decode方法，当Channel的状态变为非活动时，这个方法将会被调用一次，可以重写该方法以提供特殊的处理。

编解码器中的引用计数
	对于编解码器而言，一旦消息被编码或者被解码，就会被referenceCountUtil.release(message)调用释放，如果要保留引用以便稍后使用，那么要调用
	ReferenceCountUtil.retain(message)方法，这将会增加引用计数，从而防止该消息被释放。
	
ReplayingDecoder用异常捕获机制来做到对读取数据长度的校验，
	每次ReplayingDecoderByteBuf读取不到合适的数据就会抛出Signal，然后被捕获，忽略，继续读取，感觉略低效。
	
如果使用ByteToMessageDecoder不会引入太多复杂性，就使用，否则用ReplayingDecoder	
lineBasedFrameDecoder使用行尾控制符来解析消息数据
HTTPObjectDecoder http数据解码器
io.netty.handler.codec

MessageToMessageDecoder
	把消息从一种格式转换为另一种格式。
	
ToLongFrameException 不能让解码器缓存大量数据，以至于耗尽可用的内存。
	
MessageToByteEncoder
	encode	

解码器decoder通常要在关闭之后产生最后一个消息，因此也就有了decodeLast，这显然不适合编码器的场景，

MessageToMessageEncoder 每个通过write方法写入的消息都会被传递给encode方法，

ByteToMessageCodec	结合ByteToMessageDecoder以及MessageToByteEncoder
	先解码，然后再次编码。
	decode 
	decodeLast
	encode
MessageToMessageCodec<INBOUND_IN,OUTBOUND_IN) INBOUND_IN 网络传输类型，OUT_BOUND内部使用类型	
	decode	INBOUND -> OUTBOUND
	encode	OUTBOUNT -> INBOUND

ombinedChannelDuplexHandler 组合起来的编解码器


